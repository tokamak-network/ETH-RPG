import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { makeGenerateResponse, makeBattleFighter, makeBattleResult } from './fixtures';
import type { BattleResult } from '@/lib/types';

const mockGenerateCharacterData = vi.fn();
const mockSimulateBattle = vi.fn();
const mockSetCachedBattle = vi.fn();

vi.mock('@/lib/pipeline', () => ({
  generateCharacterData: (...args: unknown[]) => mockGenerateCharacterData(...args),
  EmptyWalletError: class EmptyWalletError extends Error {
    constructor(address: string) {
      super(`Wallet ${address} has no transactions`);
      this.name = 'EmptyWalletError';
    }
  },
}));

vi.mock('@/lib/battle', () => ({
  simulateBattle: (...args: unknown[]) => mockSimulateBattle(...args),
}));

vi.mock('@/lib/battle-cache', () => ({
  setCachedBattle: (...args: unknown[]) => mockSetCachedBattle(...args),
}));

import { executeBattle } from '@/lib/battle-pipeline';

describe('executeBattle', () => {
  const originalEnv = { ...process.env };

  beforeEach(() => {
    vi.clearAllMocks();
    process.env.NEXT_PUBLIC_SITE_URL = 'https://ethrpg.com';
    mockSetCachedBattle.mockResolvedValue(undefined);
  });

  afterEach(() => {
    process.env = { ...originalEnv };
  });

  it('generates characters, simulates, caches, and returns BattleResponse', async () => {
    const char1 = makeGenerateResponse({ address: '0xaaa' });
    const char2 = makeGenerateResponse({ address: '0xbbb' });
    mockGenerateCharacterData
      .mockResolvedValueOnce(char1)
      .mockResolvedValueOnce(char2);

    const battleResult = makeBattleResult();
    mockSimulateBattle.mockReturnValue(battleResult);

    const response = await executeBattle({
      address1: '0xaaa',
      address2: '0xbbb',
      nonce: 'test-nonce',
    });

    expect(response.result).toEqual(battleResult);
    expect(response.cached).toBe(false);
    expect(response.battleImageUrl).toContain('0xaaa');
    expect(response.battleImageUrl).toContain('0xbbb');
    expect(mockGenerateCharacterData).toHaveBeenCalledTimes(2);
    expect(mockGenerateCharacterData).toHaveBeenCalledWith('0xaaa', { skipAiLore: true });
    expect(mockGenerateCharacterData).toHaveBeenCalledWith('0xbbb', { skipAiLore: true });
    expect(mockSimulateBattle).toHaveBeenCalledOnce();
    expect(mockSetCachedBattle).toHaveBeenCalledOnce();
  });

  it('generates a nonce when none provided', async () => {
    const char1 = makeGenerateResponse({ address: '0xaaa' });
    const char2 = makeGenerateResponse({ address: '0xbbb' });
    mockGenerateCharacterData
      .mockResolvedValueOnce(char1)
      .mockResolvedValueOnce(char2);

    const battleResult = makeBattleResult();
    mockSimulateBattle.mockReturnValue(battleResult);

    const response = await executeBattle({
      address1: '0xaaa',
      address2: '0xbbb',
    });

    expect(response.result).toBeDefined();
    expect(response.cached).toBe(false);
    // Nonce should be a UUID (generated by crypto.randomUUID)
    expect(mockSimulateBattle).toHaveBeenCalledOnce();
  });

  it('caches using resolved addresses, not raw inputs', async () => {
    // Raw inputs are ENS names, but generateCharacterData resolves to 0x addresses
    const char1 = makeGenerateResponse({ address: '0xresolved1' });
    const char2 = makeGenerateResponse({ address: '0xresolved2' });
    mockGenerateCharacterData
      .mockResolvedValueOnce(char1)
      .mockResolvedValueOnce(char2);

    const battleResult = makeBattleResult();
    mockSimulateBattle.mockReturnValue(battleResult);

    await executeBattle({
      address1: 'alice.eth',
      address2: 'bob.eth',
      nonce: 'test-nonce',
    });

    // Cache should use resolved 0x addresses, not ENS names
    expect(mockSetCachedBattle).toHaveBeenCalledWith(
      '0xresolved1',
      '0xresolved2',
      'test-nonce',
      expect.objectContaining({ cached: false }),
    );
  });

  it('propagates errors from generateCharacterData', async () => {
    mockGenerateCharacterData.mockRejectedValue(new Error('Alchemy down'));

    await expect(executeBattle({
      address1: '0xaaa',
      address2: '0xbbb',
    })).rejects.toThrow('Alchemy down');
  });
});
